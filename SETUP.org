#+TITLE: Gemini REPL Project Setup
#+AUTHOR: jwalsh
#+DATE: 2025-07-13
#+PROPERTY: header-args :mkdirp yes

* Project Overview

This org file sets up the initial structure for the Gemini REPL project with formal specifications.

Execute all blocks with =C-c C-v b= (org-babel-execute-buffer).

* Directory Structure

#+begin_src shell :results output
tree -a -I '.git'
#+end_src

* Initial Files

** Git Configuration

#+begin_src text :tangle .gitignore :mkdirp t
.env
.env.local
*.pyc
__pycache__/
.DS_Store
node_modules/
target/
*.log
.lsp/
.clj-kondo/
.cpcache/
#+end_src

** Environment Template

#+begin_src shell :tangle .env.example :mkdirp t
GEMINI_API_KEY=your-api-key-here
GEMINI_MODEL=gemini-2.0-flash
GEMINI_TEMPERATURE=0.7
GEMINI_MAX_TOKENS=2048
#+end_src

** README

#+begin_src markdown :tangle README.md :mkdirp t
# Gemini REPL

An interactive console application for the Google Gemini API with formal specifications.

## Setup

1. Copy `.env.example` to `.env` and add your API key
2. Install dependencies (see language-specific instructions)
3. Run the REPL

## Project Structure

- `specs/` - Formal specifications (TLA+, Alloy)
- `src/` - Implementation
- `tests/` - Property-based tests
- `docs/` - Documentation

## Formal Methods

This project uses formal specifications to define system behavior before implementation.
See `specs/README.md` for details.
#+end_src

* Specifications

** Specifications README

#+begin_src markdown :tangle specs/README.md :mkdirp t
# Formal Specifications

This directory contains formal specifications for the Gemini REPL system.

## Specifications

- `interfaces.tla` - TLA+ specification of component interfaces
- `state.alloy` - Alloy model of system state
- `commands.tla` - Command parsing and execution specification
- `api_client.tla` - API client behavior specification

## Running Specifications

### TLA+
```bash
tlc interfaces.tla
```

### Alloy
Open in Alloy Analyzer and run checks.
#+end_src

** Requirements Document

#+begin_src markdown :tangle specs/requirements.md :mkdirp t
# Gemini API REPL System Requirements

## Overview

A lightweight, interactive console application that provides a REPL interface to the Google Gemini API, allowing users to send prompts and receive AI-generated responses in a conversational format.

## System Architecture

```mermaid
graph TD
    A[User Input] --> B[Command Parser]
    B --> C{Command Type}
    C -->|Slash Command| D[Command Handler]
    C -->|Prompt| E[API Request Builder]
    D --> F[Command Executor]
    E --> G[HTTP Client]
    G --> H[Gemini API]
    H --> I[Response Parser]
    I --> J[Output Formatter]
    J --> K[Console Display]
    F --> K
    
    L[Environment] --> M[Config Loader]
    M --> N[API Key Manager]
    N --> G
    
    O[State Manager] --> B
    O --> J
```

## Core Components

### 1. Input Handler
- **Purpose**: Capture and process user input from the console
- **Responsibilities**:
  - Read line-by-line input
  - Trim and validate input
  - Route to appropriate handler

### 2. Command Parser
- **Purpose**: Distinguish between slash commands and prompts
- **Command Format**: All commands begin with `/`
- **Parsing Rules**:
  - Commands: `/command [arguments]`
  - Prompts: Any non-slash-prefixed input

### 3. Command System

#### Core Commands
- `/help` - Display available commands and usage
- `/exit` or `/quit` - Terminate the REPL session
- `/clear` - Clear the console screen
- `/history` - Show command/prompt history
- `/save <filename>` - Save conversation to file
- `/load <filename>` - Load and replay a conversation
- `/model <model-name>` - Switch Gemini model
- `/config` - Display current configuration
- `/retry` - Retry the last prompt

#### Advanced Commands
- `/system <message>` - Set system context
- `/temperature <value>` - Adjust response randomness (0.0-1.0)
- `/max-tokens <value>` - Set maximum response length
- `/stream` - Toggle streaming responses
- `/debug` - Toggle debug mode for API calls

### 4. API Client
- **Purpose**: Handle all communication with Gemini API
- **Features**:
  - Configurable base URL and model endpoint
  - Request construction with proper headers
  - Error handling and retry logic
  - Response streaming support

### 5. Configuration Manager
- **Sources** (in priority order):
  1. Environment variables
  2. Configuration file (`~/.gemini-repl/config`)
  3. Command-line arguments
  4. Default values

- **Key Configurations**:
  - `GEMINI_API_KEY` - API authentication
  - `GEMINI_MODEL` - Default model (gemini-2.0-flash)
  - `GEMINI_TEMPERATURE` - Response creativity
  - `GEMINI_MAX_TOKENS` - Response length limit

### 6. State Manager
- **Purpose**: Maintain conversation context
- **State Elements**:
  - Conversation history
  - Current model settings
  - User preferences
  - Session metadata

### 7. Output Formatter
- **Purpose**: Present responses in a readable format
- **Features**:
  - Syntax highlighting for code blocks
  - Markdown rendering support
  - Progress indicators for long operations
  - Error message formatting

## User Interface Flow

```mermaid
sequenceDiagram
    participant User
    participant REPL
    participant Parser
    participant API
    participant Display

    User->>REPL: Launch application
    REPL->>REPL: Load configuration
    REPL->>Display: Show welcome message
    REPL->>User: Display prompt "gemini> "
    
    loop Interaction Loop
        User->>REPL: Enter input
        REPL->>Parser: Parse input
        alt Slash Command
            Parser->>REPL: Execute command
            REPL->>Display: Show command result
        else API Prompt
            Parser->>API: Send request
            API->>API: Process with Gemini
            API->>Display: Stream/Display response
        end
        Display->>User: Show output
        REPL->>User: Display prompt
    end
    
    User->>REPL: /exit
    REPL->>REPL: Save session
    REPL->>User: Goodbye message
```

## Data Structures

### Request Format
```json
{
  "contents": [{
    "parts": [{
      "text": "<user-prompt>"
    }]
  }],
  "generationConfig": {
    "temperature": <float>,
    "maxOutputTokens": <int>,
    "topK": <int>,
    "topP": <float>
  }
}
```

### Response Handling
- Parse JSON response structure
- Extract text from `candidates[0].content.parts[0].text`
- Handle error responses gracefully
- Support partial responses for streaming

## Error Handling

### Error Categories
1. **Configuration Errors**
   - Missing API key
   - Invalid configuration file
   - Unsupported model selection

2. **Network Errors**
   - Connection timeouts
   - DNS resolution failures
   - SSL certificate issues

3. **API Errors**
   - Rate limiting (429)
   - Authentication failures (401)
   - Invalid requests (400)
   - Server errors (5xx)

4. **User Input Errors**
   - Unknown commands
   - Invalid command syntax
   - Empty prompts

## Non-Functional Requirements

### Performance
- Response time < 100ms for local operations
- Streaming support for real-time response display
- Efficient memory usage for long conversations

### Usability
- Intuitive command structure
- Helpful error messages
- Command autocomplete support
- Conversation history with arrow keys

### Security
- API key never displayed in logs
- Secure storage of configuration
- No sensitive data in command history

### Extensibility
- Plugin system for custom commands
- Configurable output formatters
- Support for multiple LLM providers
- Webhook integration for responses

## Implementation Considerations

### Technology Stack
- Language: ClojureScript (as specified)
- Runtime: Node.js
- Dependencies:
  - HTTP client library
  - Readline interface
  - Configuration parser
  - Async handling

### Development Phases

1. **Phase 1: Core Functionality**
   - Basic REPL loop
   - API integration
   - Essential commands (/help, /exit)

2. **Phase 2: Enhanced Features**
   - Configuration management
   - History and persistence
   - Advanced commands

3. **Phase 3: Polish**
   - Streaming responses
   - Syntax highlighting
   - Plugin system

### Testing Strategy
- Unit tests for command parsing
- Integration tests for API client
- End-to-end tests for user workflows
- Mock API responses for offline testing
#+end_src

** TLA+ Interface Specification

#+begin_src tla :tangle specs/interfaces.tla :mkdirp t
---------------------------- MODULE interfaces ----------------------------
EXTENDS Sequences, TLC

CONSTANTS Commands, Prompts, APIKey

VARIABLES 
    inputBuffer,
    commandQueue,
    apiQueue,
    outputBuffer,
    sessionState

Init == 
    /\ inputBuffer = <<>>
    /\ commandQueue = <<>>
    /\ apiQueue = <<>>
    /\ outputBuffer = <<>>
    /\ sessionState = [
        authenticated: FALSE,
        model: "gemini-2.0-flash",
        temperature: 0.7,
        maxTokens: 2048
    ]

\* Input Handler Interface
ParseInput(input) ==
    IF input[1] = "/" 
    THEN [type |-> "command", value |-> input]
    ELSE [type |-> "prompt", value |-> input]

\* Command Parser Interface
IsValidCommand(cmd) ==
    cmd \in Commands

\* API Client Interface
CreateAPIRequest(prompt) ==
    [
        contents |-> <<[parts |-> <<[text |-> prompt]>>]>>,
        config |-> [
            temperature |-> sessionState.temperature,
            maxTokens |-> sessionState.maxTokens
        ]
    ]

\* Type Invariants
TypeInvariant ==
    /\ inputBuffer \in Seq(STRING)
    /\ commandQueue \in Seq([type: {"command"}, value: STRING])
    /\ apiQueue \in Seq([contents: Seq(SUBSET [parts: Seq(SUBSET [text: STRING])]), 
                         config: [temperature: REAL, maxTokens: Nat]])
    /\ outputBuffer \in Seq(STRING)

=============================================================================
#+end_src

** Alloy State Model

#+begin_src alloy :tangle specs/state.alloy :mkdirp t
module GeminiREPLState

sig Session {
    history: seq Message,
    config: one Configuration,
    state: one SessionState
}

sig Configuration {
    apiKey: one APIKey,
    model: one Model,
    temperature: one Int,
    maxTokens: one Int
} {
    temperature >= 0 and temperature <= 10  // 0.0 to 1.0 * 10
    maxTokens > 0 and maxTokens <= 4096
}

abstract sig Message {}
sig UserInput extends Message {
    content: one String
}
sig APIResponse extends Message {
    response: one String,
    status: one Status
}

abstract sig Status {}
one sig Success, Error, RateLimited extends Status {}

sig APIKey {}
sig Model {}
sig String {}

abstract sig SessionState {}
one sig Active, Inactive, Error extends SessionState {}

// Commands are special user inputs starting with "/"
sig Command extends UserInput {} {
    content.startsWith["/"]
}

pred validSession[s: Session] {
    s.config.apiKey != none
}

pred sendMessage[s, s': Session, input: UserInput] {
    s.state = Active
    s'.history = s.history.add[input]
    s'.config = s.config
}

assert NoEmptyHistory {
    all s: Session | s.state = Active => #s.history > 0
}

run {} for 5
#+end_src

** Command Specification

#+begin_src tla :tangle specs/commands.tla :mkdirp t
---------------------------- MODULE commands ----------------------------
EXTENDS Sequences, TLC

CONSTANTS 
    SLASH_COMMANDS,  \* Set of valid slash commands
    MAX_ARGS         \* Maximum number of arguments

VARIABLES
    commandHistory,
    currentCommand,
    executionState

\* Command structure
Command == [
    name: SLASH_COMMANDS,
    args: Seq(STRING),
    timestamp: Nat
]

\* Core commands definition
CoreCommands == {
    "/help", "/exit", "/quit", "/clear", 
    "/history", "/save", "/load", "/model",
    "/config", "/retry"
}

\* Advanced commands definition  
AdvancedCommands == {
    "/system", "/temperature", "/max-tokens",
    "/stream", "/debug"
}

Init ==
    /\ commandHistory = <<>>
    /\ currentCommand = [name |-> "/help", args |-> <<>>, timestamp |-> 0]
    /\ executionState = "idle"

\* Parse command from input string
ParseCommand(input) ==
    LET parts == SplitString(input, " ")
    IN [
        name |-> Head(parts),
        args |-> Tail(parts),
        timestamp |-> Now()
    ]

\* Validate command
IsValidCommand(cmd) ==
    /\ cmd.name \in SLASH_COMMANDS
    /\ Len(cmd.args) <= MAX_ARGS
    /\ ValidateArgs(cmd.name, cmd.args)

\* Command execution states
ExecuteCommand(cmd) ==
    /\ executionState' = "executing"
    /\ currentCommand' = cmd
    /\ commandHistory' = Append(commandHistory, cmd)

\* Safety property: No invalid commands executed
SafetyInvariant ==
    \A cmd \in Range(commandHistory): IsValidCommand(cmd)

=============================================================================
#+end_src

** API Client Specification

#+begin_src tla :tangle specs/api_client.tla :mkdirp t
---------------------------- MODULE api_client ----------------------------
EXTENDS Integers, Sequences, TLC

CONSTANTS
    API_ENDPOINT,
    MAX_RETRIES,
    TIMEOUT_MS

VARIABLES
    requestQueue,
    responseQueue,
    connectionState,
    retryCount,
    rateLimitRemaining

\* API States
ConnectionStates == {"disconnected", "connecting", "connected", "error"}

\* Request structure
Request == [
    id: Nat,
    prompt: STRING,
    config: [temperature: Real, maxTokens: Nat],
    timestamp: Nat
]

\* Response structure  
Response == [
    id: Nat,
    content: STRING,
    status: {"success", "error", "rate_limited"},
    latency: Nat
]

Init ==
    /\ requestQueue = <<>>
    /\ responseQueue = <<>>
    /\ connectionState = "disconnected"
    /\ retryCount = 0
    /\ rateLimitRemaining = 100

\* Send API request
SendRequest(req) ==
    /\ connectionState = "connected"
    /\ rateLimitRemaining > 0
    /\ requestQueue' = Append(requestQueue, req)
    /\ rateLimitRemaining' = rateLimitRemaining - 1

\* Handle rate limiting
HandleRateLimit ==
    /\ rateLimitRemaining = 0
    /\ connectionState' = "error"
    /\ UNCHANGED <<requestQueue, responseQueue, retryCount>>

\* Retry logic
RetryRequest(req) ==
    /\ retryCount < MAX_RETRIES
    /\ connectionState = "error"
    /\ retryCount' = retryCount + 1
    /\ SendRequest(req)

\* Liveness property: All requests eventually get responses
Liveness ==
    \A req \in Range(requestQueue):
        <>(
            \E resp \in Range(responseQueue):
                resp.id = req.id
        )

=============================================================================
#+end_src

* Source Structure

** Source Directory

#+begin_src markdown :tangle src/README.md :mkdirp t
# Implementation

Implementation files will be added here based on the formal specifications.

## Planned Modules

- `input_handler` - User input processing
- `command_parser` - Command parsing and validation  
- `api_client` - Gemini API communication
- `state_manager` - Session state management
- `output_formatter` - Response formatting
- `config_loader` - Configuration management
- `main` - Application entry point
#+end_src

* Testing Structure

** Test Directory

#+begin_src markdown :tangle tests/README.md :mkdirp t
# Tests

Property-based tests derived from formal specifications.

## Test Categories

- Unit tests for individual components
- Integration tests for component interactions
- Property tests based on TLA+ invariants
- Contract tests for API client
#+end_src

* Documentation

** Docs Directory

#+begin_src markdown :tangle docs/README.md :mkdirp t
# Documentation

## Contents

- Architecture diagrams
- API documentation
- User guide
- Developer guide
- Formal methods guide
#+end_src

* Project Initialization

** Initialize Git Repository

#+begin_src shell :results output
git init
git add .
git commit -m "Initial project structure with formal specifications"
#+end_src

** Create Initial Directories

#+begin_src shell :results output
mkdir -p specs src tests docs
echo "Project structure created successfully!"
ls -la
#+end_src
